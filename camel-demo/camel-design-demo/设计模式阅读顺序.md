
# 创建型模式 

## 001. 简单工厂模式
> 用于创建一系列相关或相互依赖的对象，而无需指定它们的具体类。
> 优点：
> 1. 一个调用者想创建一个对象，只要知道其名称就可以了。 
> 2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
> 3. 屏蔽产品的具体实现，调用者只关心产品的接口。

> 实现：
> 1. 一个抽象类用来定义成员变量和想要得到的结果的抽象方法
> 2. 用具体的实现类对想要得到的结果进行计算或者逻辑处理
> 3. 一个工厂类用来创建具体的实现类
> 4. 一个调用者类用来调用工厂类的方法，得到具体的实现类，然后调用实现类的方法得到想要的结果


## 1. 工厂模式 camel-design-demo-01
> 工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。
> 在工厂模式中，我们不会向客户端暴露对象创建的逻辑，并且是通过一个共同的接口来指向新创建的对象。


> 实现：
> 1. 一个抽象类用来定义成员变量和想要得到的结果的抽象方法
> 2. 用具体的实现类对想要得到的结果进行计算或者逻辑处理
> 3. 定义一个接口工厂类，对具体的实现类分别进行逻辑处理。 实现以归类进行处理的逻辑！
> 4. **对于工厂来说，工厂的接口，统筹所有场景下的，比如加减乘除，那么我只需要知道这个函数是控制加减乘除的就可以了**
> 5. **然后实例化的时候 去实例化子类，就很像Map map  = new HashMap(); 一样。Map就是个工厂**
> 6. **而hashMap就是个子类实现 ，具体hashMap里干了啥我们是不知道的 ， 但是可以直接用基于Map的hashMap实例的方法**
> 比如像 hashMap  linkedHashMap  等等，都是工厂模式。  底层都对map进行了实现，并实现了map的方法。



## 2. 抽象工厂模式 camel-design-demo-02
>抽象工厂模式是一种创建型设计模式，它能够生产相关的对象，而无需指定它们的具体类。
> https://blog.csdn.net/weixin_45477086/article/details/101717362    讲解的很好！

## 3. 建造者模式 camel-design-demo-03
> 1. 建造者模式是一种创建型设计模式，它能够将复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
> 2. 


## 4. 原型模式 camel-design-demo-04

## 5. 单例模式 camel-design-demo-05

## 6. 适配器模式 camel-design-demo-06
> 优点：
> 1. 客户端通过适配器可以透明地调用目标接口。
> 2. 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
> 3. 将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无须修改原有代码。
> 4. 一个对象适配器可以把多个不同的适配者适配到同一个目标；
> 5. 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。
> 6. 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性。
> 7. 灵活性和扩展性都非常好，可以在不修改原有系统的情况下很好地扩展系统，符合“开闭原则”。
> 8. 一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说同一个适配器可以把适配者类和它的子类都适配到目标接口。
> 9. 缺点：
> 10. 对类适配器来说，更换适配器的实现过程比较复杂。
> 11. 对象适配器和类适配器相比，要在适配器中置换适配者类比较复杂。如果一定要置换掉适配者类，只有先做到适配者类与适配目标类完全一样。
> 12. 适配器编写过程需要全面考虑，可能会增加系统的复杂性。
> 13. 适用场景：
> 14. 系统需要使用现有的类，而此类的接口不符合系统的需要。
> 15. 想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。
> 16. （仅适用于对象适配器）想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。、

## 7. 桥接模式 camel-design-demo-07
> 优点：
> 1. 分离抽象接口及其实现部分。
> 2. 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。
> 3. 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。
> 4. 实现细节对客户透明，可以对用户隐藏实现细节。
> 5. 其他的优点，如：抽象和实现的分离、优秀的扩展能力、实现细节对客户透明等，都是从更好的体现了类的职责分离原则。
> 6. 缺点：
> 7. 桥接模式的引入会增加系统的理解与设计难度。
> 8. 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，如：一个类存在两个独立变化的维度，使用桥接模式再适合不过了，但是，一个类如果存在多于两个（包括两个）独立变化的维度，使用桥接模式就不太适合了。
> 9. 桥接模式不适合用于“一次性实现”的系统，因为系统开发后期需要对系统进行扩展，而且由于抽象与实现的脱耦，扩展时无须修改原有系统的代码，符合“开闭原则”。
> 10. 适用场景：
> 11. 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系，可以使用桥接模式。
> 12. 对于那些不希望使用继承或因为多层继承导致系统类的个数剧增的系统，可以使用桥接模式。
> 13. 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
> 14. 不希望在抽象层建立静态的继承关系，或者实现层建立静态的继承关系。
> 15. 重要提示：桥接模式的核心是抽象化，其目的是脱离具体的实现而变成可扩展的，所以在设计时要遵循依赖倒置原则和里氏替换原则。


## 8. 组合模式 camel-design-demo-08
> 1. 组合模式是一种结构型设计模式，它允许你将对象组合成树形结构，并且以统一的方式对待单个对象以及组合。

## 9. 装饰器模式 camel-design-demo-09
> 优点：
> 1. 装饰器模式与继承关系的目的都是要扩展对象的功能，但是装饰器模式可以提供比继承更多的灵活性。
> 2. 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。
> 3. 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更为强大的对象。
> 4. 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。
> 5. 具体构件类与具体装饰类之间的建立关系是通过关联关系来实现的，而不是继承关系，它们之间具有较弱的耦合性，这种关联关系也称为“对象关联关系”。
> 6. 装饰器模式是一种对象结构型模式。
> 7. 适用场景：
> 8. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
> 9. 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。
> 10. 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰器模式。
> 11. 不能采用生成子类的方法进行扩充。
> 12. 重要提示：装饰器模式的核心是抽象化，其目的是脱离具体的实现而变成可扩展的，所以在设计时要遵循依赖倒置原则和里氏替换原则。
> 13. 缺点：
> 14. 使用装饰器模式进行系统设计时，需要额外考虑系统性能问题，增加装饰器会导致系统运行效率变低，同时也会增加系统设计、实现和维护的复杂性，这在一定程度上增加了系统的实现难度。
> 15. 装饰器模式的使用必须具备一定的技巧，不能随意使用，否则会导致系统变得很复杂。
> 16. 由于装饰器模式使用了大量的小对象，所以在一定程序上影响了程序的性能，而且在Java平台上，装饰器模式会因为Java的垃圾回收机制而导致一定的性能问题。
> 17. 由于装饰器模式采用了“对象关联”的方式来扩展对象的功能，而继承关系是静态的，所以在一定程度上限制了装饰器模式的功能，有一定的局限性。
> 18. 装饰器模式的引入会增加许多子类，如果过度使用会使程序变得很复杂。
> 19. 装饰器模式的引入增加了系统的理解与设计难度，由于要求装饰器的使用必须具备一定的技巧，因此在一定程度上增加了系统的实现难度。

## 10. 外观模式 camel-design-demo-10
> 优点：
> 1. 它对客户屏蔽了子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。
> 2. 它实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。
> 3. 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
> 4. 通过合理的使用外观模式，可以帮我们更好地划分访问的层次。
> 5. 迪米特法则，也称最少知道原则，指一个对象应当对其他对象有最少的了解。外观模式中的外观类Facade与客户端之间存在着依赖关系，假如Facade类对其他类的依赖过多，将导致系统的维护和扩展变得困难，因此在设计时要为之类的成员变量选择合适的访问权限。
> 6. 在层次化结构中，可以使用外观模式定义系统中每一层的入口。
> 7. 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观模式提供一个简单的接口，减少它们之间的依赖。
> 8. 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须依赖于它。此时可以为新系统开发一个外观类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。
> 9. 当构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点，如果子系统之间是相互依赖的，可以让它们仅通过外观进行通信，从而简化了它们之间的依赖关系。
> 10. 你可以让一个外观类包装多个类，因为在外观类中可以对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。
> 11. 你可以使用外观模式来设计一个“高层”接口，这个接口使得这一子系统更加容易使用。
> 12. 缺点：
> 13. 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
> 14. 如果设计不当，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。
> 15. 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类的源代码，违背了“开闭原则”。
> 16. 适用场景：
> 17. 为一个复杂子系统提供一个简单接口。
> 18. 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。
> 19. 在层次化结构中，可以使用外观模式定义系统中每一层的入口。
> 20. 当一个系统需要被分成一组相互协作的子系统时，可以使用外观模式定义子系统之间的静态关系。

## 11. 享元模式 camel-design-demo-11
> 定义：
> 1.减少创建对象的数量，以减少内存占用和提高性能。
> 场景：
> 1. 尝尝用于系统底层开发，解决系统的性能问题。
> 2. 系统有大量相似对象，需要缓冲池的场景。
> 3. 享元模式的状态的外部化和内部化
> 4. **对象的复用度非常高时，适合使用享元模式！**
> 5. **减少内存之外的其他资源暂用！**
> 6. **窗口句柄和文件句柄都是有限制的，一定要共享变量**
>
> 缺点
> 1. 享元模式使系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
> 2. 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。
>


## 12. 代理模式 camel-design-demo-12

## 13. 责任链模式 camel-design-demo-13
> 责任链模式也叫 ‘职责链模式’，是一种对象行为型模式，它通过让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

- 为请求创建了一个接收者对象（接受此次请求的链）的链。
- 类型是行为型

> 优点：
> 1. 降低耦合度。它将请求的发送者和接收者解耦。
> 2. 简化了对象。使得对象不需要知道链的结构。
> 3. 增强给对象指派职责的灵活性。当工作流程发生变化时，允许动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
> 4. 增加新的请求处理类很方便。
> 5. 有利于数据的共享，可以通过一个请求向多个对象中传递数据。
> 6. 缺点：
> 7. 不能保证请求一定被接收。
> 8. 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。
> 9. 可能不容易观察运行时的特征，有碍于除错。
> 10. 使用责任链模式必须注意，避免循环调用，避免过多的处理器，避免不必要的处理器，避免不必要的对象。
> 11. 适用场景：
> 12. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。
> 13. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
> 14. 可动态指定一组对象处理请求。
> 15. 一个对象处理不了某个请求，可以把这个请求交给另一个对象来处理。


- 



## 14. 命令模式 camel-design-demo-14
> 命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。命令模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
> 优点：
> 1. 类间解耦。调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute()方法就可以，不需要了解到底是哪个接收者执行。
> 2. 可扩展性。Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。
> 3. 命令模式结合其他模式会更优秀，如结合责任链模式，使多个接收者可以处理请求，形成一条命令执行链；结合模板方法模式，可以减少Command子类的膨胀问题。
> 缺点：
> 5. 使用命令模式可能会导致某些系统有过多的具体命令类。
> 适用场景：
> 7. 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。
> 8. 系统需要在不同的时间指定请求、将请求排队和执行请求。
> 9. 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。
> 10. 系统需要将一组操作组合在一起，即支持宏命令。

## 15. 解释器模式 camel-design-demo-15
> 解释器模式是一种类行为型模式，其别名为语言解释器模式或者解释器模式。解释器模式是一种特殊的类行为型模式，它主要用于描述如何为简单语言定义一个文法，以及如何在该语言中表示一个句子。解释器模式属于行为型模式，它是一种用于定义简单语言文法的一种方式，它通过定义一种语言的文法来定义语言的解释器，这种解释器可以是一个解释器程序，也可以是一个解释器类，甚至可以是一个简单的解释器表达式。

## 16. 迭代器模式 camel-design-demo-16
> 迭代器模式是一种对象行为型模式，其别名为游标(Cursor)模式。迭代器模式可以顺序地访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
> 迭代器模式的主要优点如下。
> 1. 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。
> 2. 迭代器简化了聚合类。由于引入了迭代器，原本需要暴露内部结构的聚合对象不再需要暴露内部结构，可以让聚合对象有更好的封装性。
> 3. 在同一个聚合对象上可以定义多个遍历，可以同时遍历该聚合对象，而且还可以为遍历的过程设置不同的遍历起点，甚至可以设置不同的遍历方向，这一点在迭代器模式中得到了体现。
> 4. 迭代器模式提供了一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。
> 5. 迭代器模式为遍历不同的聚合结构提供一个统一的接口，在该模式中可以为不同的聚合结构提供多种遍历方式，而且还可以支持以不同的方式遍历一个聚合对象。
> 6. 迭代器模式中的迭代器可以是一个简单的遍历指针，也可以是一个复杂的遍历器，它可以完成对聚合对象的多种遍历，甚至可以实现对聚合对象的并行遍历。
> 7. 迭代器模式为遍历不同的聚合结构提供了一个统一的接口，从而支持对聚合结构的多态遍历。
> 8. 主要缺点如下:
> 9. 由于迭代器模式将存储数据和遍历数据的职责分离开来，所以增加新的聚合类和迭代器类都比较麻烦，必须要修改对应的接口，这样会导致系统中类的个数成对增加，增加了系统实现的复杂度。
> 10. 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator来实现，而ListIterator又是List接口的子接口，这违背了迭代器模式的初衷，即“为遍历不同的聚合结构提供一个统一的接口”。
> 11. 具体迭代器的设计也很难，需要考虑到对不同聚合结构的遍历，不同的遍历方式以及对遍历过程中可能出现的改变聚合结构的操作等情况，迭代器的设计会比较复杂。
> 12. 使用场景如下:
> 13. 访问一个聚合对象的内容而无需暴露它的内部表示。
> 14. 需要为聚合对象提供多种遍历方式。
> 15. 为遍历不同的聚合结构提供一个统一的接口。

## 17. 中介者模式 camel-design-demo-17
>
> 优点：
> 1. 减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者。
> 2. 各个同事类之间解耦，可以独立的变化和复用。
> 3. 将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可。
> 4. 减少子类生成，降低系统的复杂度。
> 5. 缺点：
> 6. 中介者会庞大，变得复杂难以维护。
> 7. 适用场景：
> 8. 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。
> 9. 交互的公共行为，如果需要改变行为则可以增加新的中介者类。
> 10. 一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。
> 11. 一个对象引用其他很多对象并且直接和这些对象通信，导致难以复用该对象。
> 12. 想定制一个分布在多个类中的行为，而又不想生成太多的子类。
> 13. 需要在几个类之间共享行为，但是又不想生成太多的子类。
> 14. 一个类定义了多个行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。
> 15. 需要控制一个对象的行为，而不能采用继承的方式进行扩充。
> 16. 一个对象的行为取决于它所关联的对象，如果需要改变这些关联，可以增加新的中介者类。
> 17. 一个对象必须协同其他对象才能完成某些任务，而且它不知道其他对象的情况，此时可以使用中介者模式来进行设计。
> 18. 一个对象的行为依赖于它所关联的对象，而且它必须在运行时刻才能知道它所关联的对象。
> 19. 一个对象必须与其他对象协同工作，但是它不知道其他对象的细节，此时可以使用中介者模式来进行设计。
> 20. 
## 18. 备忘录模式 camel-design-demo-18

> 优点：
> 1. 为用户提供一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态。
> 2. 实现了信息的封装，使得用户不需要关心状态的保存细节。
> 3. 缺点：
> 4. 资源消耗过大，如果类的成员变量太多，就不可避免的要占用大量的内存。
> 5. 适用场景：
> 6. 需要保存和恢复数据的相关状态场景。
> 7. 提供一个可回滚的操作。
> 8. 需要监控的副本场景。

> 场景很少  :   一般在开发文本wps等软件的时候会用到，比如撤销操作，这个时候就可以用到备忘录模式。

## 19. 观察者模式 camel-design-demo-19

> 优点：
> 1. 观察者和被观察者之间是抽象耦合的。
> 2. 建立一套触发机制。
> 3. 缺点：
> 4. 如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。
> 5. 如果在观察者和被观察者之间存在循环引用，将会导致系统崩溃。
> 6. 如果观察者对象在处理通知的时候抛出异常，将会影响其他观察者的接收。
> 7. 适用场景：
> 8. 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
> 9. 事件多级触发场景。
> 10. 跨系统的消息交换场景，如消息队列的处理机制。
> 11. 事务处理机制。
> 


## 20. 策略模式 camel-design-demo-20
> 优点：
> 1. 策略类之间可以自由切换。
> 2. 易于扩展。
> 3. 避免使用多重条件转移语句。
> 4. 缺点：
> 5. 策略类会增多。
> 6. 所有策略类都需要对外暴露。
> 7. 适用场景：
> 8. 系统有很多类，而区分它们的只是他们直接的行为。
> 9. 一个系统需要动态地在几种算法中选择一种。
> 10. 需要屏蔽算法规则的场景。
> 11. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。可以把相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。
> 12. 算法需要自由切换的场景。
> 13. 算法中需要使用的数据不应该让其他算法知道的场景。
## 21. 状态模式 camel-design-demo-21

> 优点：
> 1. 封装了转换规则。
> 2. 枚举可能的状态，在枚举状态之前需要确定状态种类。
> 3. 将所有与某个状态有关的行为都放入一个类中，只需要改变对象所属的类就可以改变对象的状态，还可以增加新的状态。
> 4. 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件分支语句。
> 5. 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。
> 6. 缺点：
> 7. 状态模式的使用必然会增加系统类和对象的个数。
> 8. 状态模式的结构与实现都较为复杂，如果使用不当，会导致程序结构和代码的混乱。
> 9. 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源码。
> 10. 适用场景：
> 11. 行为随状态改变而改变的场景。
> 12. 条件、分支语句的代替者。
> 13. 一个操作中含有庞大的多分支结构，且这些分支决定于对象的状态。
> 14. 需要根据一个对象的状态来决定其行为，但是不能将条件语句的分支结构和对象的状态混合在一个操作中。
> 15. 一个对象的行为取决于它的状态，而且它必须在运行时刻根据状态改变它的行为。
> 


## 22. 模板方法模式 camel-design-demo-22

## 23. 访问者模式 camel-design-demo-23

> 优点：
> 1. 扩展性好。增加新的访问操作很方便。
> 2. 复用性好。可以通过这种方式来定义整个对象结构通用的功能。
> 3. 灵活性好。可以访问一个对象结构中的不同类型的元素，而不需要改变这个元素的类。
> 4. 符合单一职责原则。访问者模式把数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。
> 5. 缺点：
> 6. 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。
> 7. 违背了依赖倒置原则。访问者依赖的是具体元素，而不是抽象元素。
> 8. 具体元素变更比较困难。如果一个具体元素变更了，比如增加了一个方法，那么所有的访问者都要进行修改。
> 9. 违背了单一职责原则。访问者模式把数据结构和作用于结构上的操作耦合在一起，这样违背了类的职责单一原则。
> 10. 适用场景：
> 11. 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。
> 12. 需要对一个对象结构中的对象进行很多不同且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
> 13. 对象结构中的对象需要提供多种不同且不相关的操作，而且需要避免让这些操作“污染”这些对象所属的类。
> 14. 需要为一个对象结构中的对象提供很多不同且不相关的操作，而且这些操作需要避免让这些对象本身发生变化，也不希望在增加新操作时修改这些类。
> 15. 需要定义对象结构的类很少改变，但经常需要在此对象结构上定义新的操作。
> 
> 
> 
> 


