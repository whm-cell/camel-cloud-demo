
# 创建型模式 

## 001. 简单工厂模式
> 用于创建一系列相关或相互依赖的对象，而无需指定它们的具体类。
> 优点：
> 1. 一个调用者想创建一个对象，只要知道其名称就可以了。 
> 2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
> 3. 屏蔽产品的具体实现，调用者只关心产品的接口。

> 实现：
> 1. 一个抽象类用来定义成员变量和想要得到的结果的抽象方法
> 2. 用具体的实现类对想要得到的结果进行计算或者逻辑处理
> 3. 一个工厂类用来创建具体的实现类
> 4. 一个调用者类用来调用工厂类的方法，得到具体的实现类，然后调用实现类的方法得到想要的结果


## 1. 工厂模式 camel-design-demo-01
> 工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。
> 在工厂模式中，我们不会向客户端暴露对象创建的逻辑，并且是通过一个共同的接口来指向新创建的对象。


> 实现：
> 1. 一个抽象类用来定义成员变量和想要得到的结果的抽象方法
> 2. 用具体的实现类对想要得到的结果进行计算或者逻辑处理
> 3. 定义一个接口工厂类，对具体的实现类分别进行逻辑处理。 实现以归类进行处理的逻辑！
> 4. **对于工厂来说，工厂的接口，统筹所有场景下的，比如加减乘除，那么我只需要知道这个函数是控制加减乘除的就可以了**
> 5. **然后实例化的时候 去实例化子类，就很像Map map  = new HashMap(); 一样。Map就是个工厂**
> 6. **而hashMap就是个子类实现 ，具体hashMap里干了啥我们是不知道的 ， 但是可以直接用基于Map的hashMap实例的方法**
> 比如像 hashMap  linkedHashMap  等等，都是工厂模式。  底层都对map进行了实现，并实现了map的方法。



## 2. 抽象工厂模式 camel-design-demo-02
>抽象工厂模式是一种创建型设计模式，它能够生产相关的对象，而无需指定它们的具体类。
> https://blog.csdn.net/weixin_45477086/article/details/101717362    讲解的很好！

## 3. 建造者模式 camel-design-demo-03
> 1. 建造者模式是一种创建型设计模式，它能够将复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
> 2. 
> 
> 


## 4. 原型模式 camel-design-demo-04

## 5. 单例模式 camel-design-demo-05

## 6. 适配器模式 camel-design-demo-06

## 7. 桥接模式 camel-design-demo-07
> 1. 桥接模式是一种结构型设计模式，它将抽象部分与它的实现部分分离，使它们都可以独立地变化。


## 8. 组合模式 camel-design-demo-08
> 1. 组合模式是一种结构型设计模式，它允许你将对象组合成树形结构，并且以统一的方式对待单个对象以及组合。

## 9. 装饰器模式 camel-design-demo-09

## 10. 外观模式 camel-design-demo-10

## 11. 享元模式 camel-design-demo-11
> 定义：
> 1.减少创建对象的数量，以减少内存占用和提高性能。
> 场景：
> 1. 尝尝用于系统底层开发，解决系统的性能问题。
> 2. 系统有大量相似对象，需要缓冲池的场景。
> 3. 享元模式的状态的外部化和内部化
> 4. **对象的复用度非常高时，适合使用享元模式！**
> 5. **减少内存之外的其他资源暂用！**
> 6. **窗口句柄和文件句柄都是有限制的，一定要共享变量**
>
> 缺点
> 1. 享元模式使系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
> 2. 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。
>


## 12. 代理模式 camel-design-demo-12

## 13. 责任链模式 camel-design-demo-13
> 责任链模式也叫 ‘职责链模式’，是一种对象行为型模式，它通过让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

- 为请求创建了一个接收者对象（接受此次请求的链）的链。
- 类型是行为型

> 优点：
> 1. 降低耦合度。它将请求的发送者和接收者解耦。
> 2. 简化了对象。使得对象不需要知道链的结构。
> 3. 增强给对象指派职责的灵活性。当工作流程发生变化时，允许动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
> 4. 增加新的请求处理类很方便。
> 5. 有利于数据的共享，可以通过一个请求向多个对象中传递数据。
> 6. 缺点：
> 7. 不能保证请求一定被接收。
> 8. 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。
> 9. 可能不容易观察运行时的特征，有碍于除错。
> 10. 使用责任链模式必须注意，避免循环调用，避免过多的处理器，避免不必要的处理器，避免不必要的对象。
> 11. 适用场景：
> 12. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。
> 13. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
> 14. 可动态指定一组对象处理请求。
> 15. 一个对象处理不了某个请求，可以把这个请求交给另一个对象来处理。


- 



## 14. 命令模式 camel-design-demo-14

## 15. 解释器模式 camel-design-demo-15

> 待琢磨

## 16. 迭代器模式 camel-design-demo-16

## 17. 中介者模式 camel-design-demo-17
>
> 优点：
> 1. 减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者。
> 2. 各个同事类之间解耦，可以独立的变化和复用。
> 3. 将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可。
> 4. 减少子类生成，降低系统的复杂度。
> 5. 缺点：
> 6. 中介者会庞大，变得复杂难以维护。
> 7. 适用场景：
> 8. 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。
> 9. 交互的公共行为，如果需要改变行为则可以增加新的中介者类。
> 10. 一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。
> 11. 一个对象引用其他很多对象并且直接和这些对象通信，导致难以复用该对象。
> 12. 想定制一个分布在多个类中的行为，而又不想生成太多的子类。
> 13. 需要在几个类之间共享行为，但是又不想生成太多的子类。
> 14. 一个类定义了多个行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。
> 15. 需要控制一个对象的行为，而不能采用继承的方式进行扩充。
> 16. 一个对象的行为取决于它所关联的对象，如果需要改变这些关联，可以增加新的中介者类。
> 17. 一个对象必须协同其他对象才能完成某些任务，而且它不知道其他对象的情况，此时可以使用中介者模式来进行设计。
> 18. 一个对象的行为依赖于它所关联的对象，而且它必须在运行时刻才能知道它所关联的对象。
> 19. 一个对象必须与其他对象协同工作，但是它不知道其他对象的细节，此时可以使用中介者模式来进行设计。
> 20. 
## 18. 备忘录模式 camel-design-demo-18

> 优点：
> 1. 为用户提供一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态。
> 2. 实现了信息的封装，使得用户不需要关心状态的保存细节。
> 3. 缺点：
> 4. 资源消耗过大，如果类的成员变量太多，就不可避免的要占用大量的内存。
> 5. 适用场景：
> 6. 需要保存和恢复数据的相关状态场景。
> 7. 提供一个可回滚的操作。
> 8. 需要监控的副本场景。

> 场景很少  :   一般在开发文本wps等软件的时候会用到，比如撤销操作，这个时候就可以用到备忘录模式。

## 19. 观察者模式 camel-design-demo-19

> 优点：
> 1. 观察者和被观察者之间是抽象耦合的。
> 2. 建立一套触发机制。
> 3. 缺点：
> 4. 如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。
> 5. 如果在观察者和被观察者之间存在循环引用，将会导致系统崩溃。
> 6. 如果观察者对象在处理通知的时候抛出异常，将会影响其他观察者的接收。
> 7. 适用场景：
> 8. 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
> 9. 事件多级触发场景。
> 10. 跨系统的消息交换场景，如消息队列的处理机制。
> 11. 事务处理机制。
> 


## 20. 策略模式 camel-design-demo-20
> 优点：
> 1. 策略类之间可以自由切换。
> 2. 易于扩展。
> 3. 避免使用多重条件转移语句。
> 4. 缺点：
> 5. 策略类会增多。
> 6. 所有策略类都需要对外暴露。
> 7. 适用场景：
> 8. 系统有很多类，而区分它们的只是他们直接的行为。
> 9. 一个系统需要动态地在几种算法中选择一种。
> 10. 需要屏蔽算法规则的场景。
> 11. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。可以把相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。
> 12. 算法需要自由切换的场景。
> 13. 算法中需要使用的数据不应该让其他算法知道的场景。
## 21. 状态模式 camel-design-demo-21

> 优点：
> 1. 封装了转换规则。
> 2. 枚举可能的状态，在枚举状态之前需要确定状态种类。
> 3. 将所有与某个状态有关的行为都放入一个类中，只需要改变对象所属的类就可以改变对象的状态，还可以增加新的状态。
> 4. 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件分支语句。
> 5. 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。
> 6. 缺点：
> 7. 状态模式的使用必然会增加系统类和对象的个数。
> 8. 状态模式的结构与实现都较为复杂，如果使用不当，会导致程序结构和代码的混乱。
> 9. 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源码。
> 10. 适用场景：
> 11. 行为随状态改变而改变的场景。
> 12. 条件、分支语句的代替者。
> 13. 一个操作中含有庞大的多分支结构，且这些分支决定于对象的状态。
> 14. 需要根据一个对象的状态来决定其行为，但是不能将条件语句的分支结构和对象的状态混合在一个操作中。
> 15. 一个对象的行为取决于它的状态，而且它必须在运行时刻根据状态改变它的行为。
> 


## 22. 模板方法模式 camel-design-demo-22

## 23. 访问者模式 camel-design-demo-23

> 优点：
> 1. 扩展性好。增加新的访问操作很方便。
> 2. 复用性好。可以通过这种方式来定义整个对象结构通用的功能。
> 3. 灵活性好。可以访问一个对象结构中的不同类型的元素，而不需要改变这个元素的类。
> 4. 符合单一职责原则。访问者模式把数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。
> 5. 缺点：
> 6. 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。
> 7. 违背了依赖倒置原则。访问者依赖的是具体元素，而不是抽象元素。
> 8. 具体元素变更比较困难。如果一个具体元素变更了，比如增加了一个方法，那么所有的访问者都要进行修改。
> 9. 违背了单一职责原则。访问者模式把数据结构和作用于结构上的操作耦合在一起，这样违背了类的职责单一原则。
> 10. 适用场景：
> 11. 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。
> 12. 需要对一个对象结构中的对象进行很多不同且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
> 13. 对象结构中的对象需要提供多种不同且不相关的操作，而且需要避免让这些操作“污染”这些对象所属的类。
> 14. 需要为一个对象结构中的对象提供很多不同且不相关的操作，而且这些操作需要避免让这些对象本身发生变化，也不希望在增加新操作时修改这些类。
> 15. 需要定义对象结构的类很少改变，但经常需要在此对象结构上定义新的操作。
> 
> 
> 
> 


